<!--
                 file : c.md
        creation date : 27-04-2017 09:06
           created by : Hubert Li
        last modified : 2017年04月27日  9:13:32
            copyright : 2015-2019 by Hubert Li
                             Strictly Confidential
                             All rights reserved.
                       No part of this hardware description, either
                       material or conceptual may be copied or distributed,
                       transmitted, transcribed, stored in a retrieval system
                       or translated into any human or computer language in
                       any form by any means, electronic, mechanical, manual
                       or otherwise, or disclosed to third parties without
                       the express written permission of Hubert Li
-->

### 1.c程序的基本结构
```
   #include<库文件、头文件>   //.h是头文件
   void main()                //主程序  函数类型 函数名 (参数)*/
   {
                              //程序主体
   }
```

### 2.常用库文件
```
   stdio.h                    标准i/o库文件
   stdbool.h                  把bool定义为逻辑类型的别名
   math.h                     函数头文件 
   stdlib.h                   使用以上4个函数，需要头文件stdlib.h 
```
   对C++ Builder中random()函数说明的翻译:
 
* 1)random 函数
   * random函数返回一个0~num-1之间的随机数. random(num)是在stdlib.h中的一个宏定义. num和函数返回值都是整型数.
```
    所在的头文件  stdlib.h
    原型  int random(int num);
```
* 2)memset 函数
```
    头文件   <memory.h>或<string.h>
    原型      void *memset(void *s, int ch, size_t n);
    函数解释：将s中前n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。
```

### 3.词法
   1)标识符
    在程序中使用的变量名、函数名、标号等统称为标识符。除库函数的函数名由系统定义外，其余都由用户自定义。C 规定，标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线(_)组成的字符串，并且其第一个字符必须是字母或下划线。
      (1)标准C不限制标识符的长度，但它受各种版本的C 语言编译系统限制，同时也受到具体机器的限制
      (2)在标识符中，大小写是有区别的
   2)关键字、保留字
      (1)类型说明符
         用于定义、说明变量、函数或其它数据结构的类型.
      (2)语句定义符
         用于表示一个语句的功能。如if else
      (3)预处理命令字
         用于表示一个预处理命令。如前面各例中用到的include。
   3)运算符
   //*****************************************************************//
   4)分隔符
      在Ｃ语言中采用的分隔符有逗号和空格两种
      逗号主要用在类型说明和函数参数表中，分隔各个变量。
      空格多用于语句各单词之间，作间隔符
   
4.常量
   定义赋值格式
   #define 标识符 数值 
5.变量
   1)整型变量
      分signed 和 unsigned两种,默认是 signed型
      short型：2Bytes   16bit
      long 型：4Bytes   32bit
      int  型：2/4Bytes 16/32bit
   //*****************************************************************//
      gcc:     int 4Bytes
      BC3.1:   int 2Bytes
      
   //*****************************************************************//
      后缀 (Suffix)：显式指定常量的类型
         l、L  表示常量是一个长整型
         u、U  表示常量是一个无符号整型数
         两种后缀可以一起使用
      
   2)浮点型
      (1)常量表示
         十进制  ：1.25 0.125
         指数形式：123.4e-5 = 12.3e-4 = 1.234e-3 = 0.1234e-2
      (2)变量类型
         存放：符号(1bit)，指数部分(基2），小数部分(1.f,f是存放值)
         float       : 32 bit 1 + 8  + 23
         double      : 64 bit 1 + 11 + 52
         long double : 128bit
   3)字符型
      char     : 8 bit     //以ACSII码存储
      常量表示：单引号引起
   4)字符串型
      string : 
   //*****************************************************************//
      存放：字符串结尾有一个空字符 ( ASCII=0, '\0')作为字符串结束标志
            字符串结束标志'\0'是不能显示的，在字符串常量中，也不用显式写出来
            test : 存放 't' 'e' 's' 't' '\0'   \0='h0(8bit)
      常量表示：双引号引起
   5)运算中的类型转换
      整型、字符型、浮点型数据可混合运算
      混合运算时，不同类型的数据按照一定的规则先转换为同一类型，然后再运算。【隐式转换】
   
6.运算符
   1)强制类型转换运算符
      形式: (类型名)操作数
   //*****************************************************************//
   2)自增++、自减-- 运算符
      形式
         ++i, --i 使用i之前，先使i的值加/减1
         i++, i-- 使用i之后，再使i的值加/减1

7.输入、输出函数
   1)基本输入输出
      库：<stdio.h>
      (1)字符输出函数 putchar     :  int putchar(int c); 返回c的ACSII码值
      (2)字符输入函数 getchar     :  int getchar(void);  返回输入的ACSII码值
      (3)格式输出函数 printf      :  int printf(char* format[, args...]);
             格式化输出若干任意类型数据
             参数说明
               char* format  格式控制字符串
                  包括“格式说明”和“普通字符”
                     “格式说明”由%和“格式字符”组成，将输出数据按指定格式输出
                     “普通字符”按原样输出
                  ---------------------------------------------------------
                     格式字符          含义
                  ---------------------------------------------------------
                     d,i               有符号十进制
                     u                 无符号十进制
                     o                 无符号八进制
                     x,X               无符号十六进制
                     f                 单精度，双精度小数，默认6位小数
                     c                 无符号字符串
                     s                 字符串
                  ---------------------------------------------------------
                  l 用于长整型整数，可加在格式符d，o，x，u前面
                  m （代表一个正整数）：数据最小宽度
                  n （代表一个正整数）：对实数，表示输出n位小数；  
                     对字符串，表示截取的字符个数
                  -   输出的数字或字符在域内向左靠
                                               
               args  需要输出的数据列表，可以多个或没有
             返回值
               若成功，返回输出的字节数，包括换行符
               若失败，返回EOF (End of File)

      4)格式输入函数     scanf       :  int scanf(char* format[, addrs...]);
         addrs    :  需要输入的地址列表，可以有多个
         返回值   :  返回输入并赋值的数据项的个数
         关于输入格式
   //*****************************************************************//
            格式字符串中的普通字符须按相应位置输入
            除字符型(%c)外，输入项之间用一个或多个空白字符分隔，包括空格、回车、制表符
   //*****************************************************************//
            空白字符会作为%c对应的输入，如果需要输入下一个非空白字符，可以用%1s
            如规定了最大宽度，且输入数据超出宽度，则按宽度截取数据
         
      5)字符串输出函数 puts
      6)字符串输入函数 gets
      
8.函数
   1)函数定义
      类型 函数名（参数声明）
      {
         声明部分；
         语句；
      }
   //*****************************************************************//
      (1)类型：返回值
         若省略此项，则认为返回类型是int
         若无返回值，则定义返回类型为void
            函数需要返回值时，若缺少return语句，或return语句未带返回值，则返回一个不确定值
      (2)“声明部分”
         指变量、函数的声明
      (3)形式参数和实际参数
         形参：定义函数时，函数名后()中的参数
         实参：调用函数时，函数名后()中的参数
         值传递
            实参对形参的数据传递是“值传递”
         单向传递
            只能把实参的值传递给形参
            不能把形参的值传递给实参
            对形参的值所作的改变不能带回给实参
         实参和形参是不同的变量
            具有不同的存储空间
            具有不同的生存期和作用域
   2)函数原型 (Prototype)
      一般形式
         类型 函数名(类型1, 类型2, ...);
         类型 函数名(类型1 形参1,
                 类型2 形参2, ...);
   3)函数声明
      (1)函数声明的形式即函数原型
      (2)在函数调用之前，应对函数进行声明
      (3)函数声明可以在主调函数的声明部分，也可以在函数外部
         函数外部的声明，对所有主调函数都起作用，不需要在主调函数内再次声明
   //*****************************************************************//
      (4)函数的定义也具有声明的作用
   //*****************************************************************//
      (5)库函数的声明包括在头文件(*.h)里，不需在源程序里声明
      
   4)函数调用
      (1)形式
         函数名(实参表列)
      (2)函数的嵌套调用
         主函数调用 a 函数，a调用b函数，b调用……
      (3)函数的递归调用
         一个函数直接或间接的调用它自身
         必须有一定的条件判断语句，使得递归调用能够终止。
   5)数组与函数参数 
      (1)数组元素作为函数的实参
         和变量做实参一样，“值传递”
   //*****************************************************************//
      (2)数组名作为函数的实参
         C语言中的数组名代表了数组在内存中存放的起始地址，所以数组名作为函数的参数传递的是数组的起始地址，属于“传地址”。
         说明：
         （1）用数组名作为函数的参数，必须对实参数组先定义，形参必须说明成与实参数组类型一致的数组。                             //*********//
              声明数组类型形参时，不需要指定数组长度(多维除外)            
         （2）形参数组和实参数组的数组名可以不一样，数组的大小也可以不一致。由于传递的是地址，所以形参数组和实参数组在内存中实际上是共用了连续的一块地址空间。
          (3) 以数组作为实参的几种方法
               （1）形参用数组名    实参用数组名
               （2）形参用指针变量 实参用数组名
               （3）形参用数组名    实参用指针变量
               （4）形参用指针变量 实参用指针变量

   6)变量的作用域和生存期
      按照作用域可分为：局部变量 和 全局变量
      局部变量：
         函数或复合语句内部定义的变量
         说明
            作用域为本函数或复合语句范围
            不同函数内的局部变量可以重名，它们是不同的变量，作用域不同，不会相互干扰
            函数形参也是局部变量的一种
            若多个同名局部变量作用域重叠，则最内层复合语句中定义的局部变量有效
      全局变量：
         作用域从变量定义处到本源程序文件结束
         全局变量可以被本文件的函数所共用
      
   //*****************************************************************//
      按照生存期可分为：静态存储 和 动态存储 
      静态存储方式:
         程序运行期间分配固定的存储空间
         全局变量全部存放在静态存储区中
      动态存储方式
         程序运行期间根据需要动态分配存储空间
         函数形参、自动变量等
         每次调用函数时，给该函数中的局部变量和形参分配存储空间，函数返回后释放空间
   7)变量的存储类型
      自动变量     auto
         局部变量，用auto关键字修饰
         auto可以省略，是缺省的存储方式
         自动分配和释放存储空间
      寄存器变量 register
         存放在CPU寄存器中，存取速度快
         寄存器变量只能动态分配存储空间(寄存器)
         只有自动变量和形参可以作为寄存器变量
      静态变量     static
         局部变量，用static关键字修饰
         静态局部变量为静态存储，整个程序运行期间都不释放，其值不会丢失
         在函数调用结束后，静态局部变量虽仍然存在，但已经不在变量的作用域内，所以其他函数不能引用它
         静态局部变量在编译时赋初值，且只赋一次
         若不对静态局部变量赋初值，则初值为0
      外部变量     extern
         用途：用extern声明外部变量。           /******************************************8/
         适用对象：未用static声明的外部变量
         用extern声明外部变量，以扩展外部变量的作用域：
         在一个文件内：在某变量定义之前要使用它，则声明外部变量。
         在多文件程序中：在一个c文件中引用其他c文件定义的外部变量，可以声明外部变量，
         外部变量的定义一般放在所有函数之前

9.编 译  预  处  理
   1)预处理概念
      在编译之前对源程序进行“预处理”
      预处理命令不是C语句，末尾没有分号
      预处理命令不在可执行文件中执行
      预处理命令都以#开始
      包括宏定义、文件包含、条件编译等
   2)宏定义
      (1)不带参数
         #define 标识符 字符串
         说明
            把源程序中相应标识符予以替换
            仅是简单的字符串替换，没有任何语法正确性检查
            有效范围从定义处开始，到文件结束，或者由#undef命令终止作用域
            行末没有分号，如有分号将会被一起替换
      (2)带参数
         #define 宏名(参数表) 字符串
         说明
            宏定义仅是把参数作为字符串做简单替换，而不做任何运算求值和语法检查
            宏名与参数表的括号之间不应有空格
            应注意参数替换后可能出现的语法错误和意料之外的运算
            应在宏定义内容及其中参数两边加上括号
            例：#define S2(a,b) ((a)*(b))
   3)文件包含
      一般形式
         #include "filename"
         #include <filename>
      说明
         把另一个源文件的全部内容包含进来
         预编译后，它们已成为一个文件
         头文件的扩展名一般用.h，但并非规
         调用库函数一般使用<>，也可以使用""
         调用用户编写的头文件应使用""
   4)条件编译
      对某些部分的源程序指定编译的条件
      可以减少被编译的语句，减少目标程序的长度，减少运行时间
      有利于移植程序，增加程序的灵活性
      命令形式
         #ifdef...#else...#endif
         #ifndef...#else...#endif
         #if...#else...#endif

10.指针
   1).变量的指针和指针变量
      变量的指针
         内存中存储某个变量的存储单元的首地址
         指针(地址)实质上是一个整数(不是C的整型)
         可以通过变量的地址来间接的访问变量
      指针变量
         指针(地址)是一个数据，也可以用另一个变量来存放，即指针变量
         通过指针变量可以间接访问变量或内存数据
   
   2)指针变量定义
      一般形式
         基类型 *指针变量名;
      说明
         “基类型”表示该指针指向的数据的类型
         可以定义基类型为空类型void的指针变量
   3)地址运算符 &
      获得操作数的地址(指针)
      单目运算符，自右向左结合，优先级较高
      操作数应为各种类型的内存变量、数组元素、结构体成员等
      操作数不能是表达式、常量、寄存器变量
   4)指针运算符 *
      获得指针指向的内存数据
      又称“间接访问运算符”
      单目运算符，自右向左结合，优先级较高
      操作数为具有指针(地址)意义的值
   5)指针变量作为函数参数
      参数传递
         仍然遵循“单向值传递”的规则
         这里的传递规则是指针类型参数的值的传递
         作为参数的指针型实参的值不会改变
         但是对指针型实参所指向的内存数据所作的操作将不会随函数的返回而恢复
      用途
         借助指针类型参数可以改变多个数据的值
    6)指针的运算
      运算类型
         算术运算：加、减、自增、自减
            条件：p,q是指向同一数据集合(数组)的指针
         关系运算：所有关系运算
            条件
               p,q是指向同一数据集合(数组)的指针
            运算方式
               p<q、p<=q、p==q、p!=q、p>=q、p>q
               p<q:判断p所指元素是否在q所指元素之前
               其他运算的含义与上述类似
               若p,q不是指向同一数据集合的指针，则运算无意义
         赋值运算：一般赋值、加赋值、减赋值
            条件
               p,q是指向同一数据类型的指针
               n是整型数据
               p=+q,q-n,q+n……            
         上述运算在一定约束条件下才有意义(后详)
         指针的运算还包括
            指针运算
            对指向数组的指针的下标运算
            对指针变量的取地址运算
            对指向结构体的指针的指向成员运算
   7)指向二维数组的指针 
      1)举例
         char a[3][4];
            a、a+1、a+2都是指针，它们的基类型是长度为4的字符数组，它们与下面定义的指针p同类型  char (*p)[4];
            *a,*(a+1),*(a+2) 还是指针，基类型是char。
            *(*a),*(*a+1),*(*a+2),*(*a+3) 是a[0][i]的四个char数组元素。
      2)二维数组 char a[3][4]
         a：指向二维数组的指针类型
         表示第i行
            a[i]、*(a+i)：指向一维数组的指针类型   
         表示第i行j列的元素
            a[i][j]、  *(*(a+i)+j)
            *(a[i]+j)、(*(a+i))[j]：char类型
         注意a和*a都是指针，但是基类型不同
         注意*(a+i)和*a+i的区别

      3)指向二维数组的指针变量
         指向数组元素的指针变量
            指向二维数组的元素
            类型为 char * p;
            根据一维数组元素和二维数组元素的对应关系，可以访问所有的二维数组元素
            char a[M][N];
            char *p=a[0]; /* p=*a; */
            则p[i*N+j]、*(p+i*N+j)、a[i][j]
            表示二维数组第i行j列的元素
         
         基类型为一维数组的指针变量
            指向二维数组的行
            类型为 char (*p)[4];
            把每一行作为一个一维数组来处理
            举例：
               int a[M][N];
               int (*p)[N]=a; /* p=a; */
               则p[i]、*(p+i)、a[i]表示数组的第i行
               且p[i][j]、*(*(p+i)+j)、*(p[i]+j)、(*(p+i))[j]表示二维数组第i行j列的元素

      4)直接用字符指针指向字符串
         字符串常量按字符数组处理，在存储器中占有一定的空间，并有自己的地址(指针)
         可以把字符串常量的地址赋给字符指针变量
         通过这个字符指针变量可以修改字符串常量
         两个内容完全一样的字符串常量，在存储器中是不同的字符串，具有不同的存储空间
         //***************************************************************************************************************//
            串常量能对数组赋初值，如同把字符串的各个字符放到数组中；不能在其他场合对数组整体赋值，char a[4];a=“abc”;是错的
            
   8)指向函数的指针变量
      1)含义
         函数的指令存储在内存中的一段空间中
         函数也有相应的内存地址
         函数的入口地址就是函数的指针
         函数名代表函数的入口地址
         函数的指针可以用相应类型的指针变量表示，即指向函数的指针变量
         函数也可以用通过指针变量间接调用
      2)定义形式
         类型 (*变量名)([参数类型列表]);
         说明
            与函数原型类似，函数名用(*变量名)代替
            参数类型列表，只有类型，没有变量 
            “参数类型列表”可以省略，但一般不要省略
            主要用于函数的参数                       //******可以将函数，用作参数*******//
               double y1, y2, y3;
               y1 = integral(sin, 0.0, 1.0);
               y2 = integral(cos, 0.0, 2.0);
               y3 = integral(exp, 0.0, 3.5);
               double integral(double (*f)(double),
                               double a, double b)  
                              
            先赋值，后使用，一般用同类型函数名赋值
               int (*p)(int, int); /* 定义指针变量 */
               int a, b, c;
               p = max;        /* 用函数名赋值 */                    //*** 难道函数名，也像数组名一样，是个指针？？？函数名代表函数的入口地址**///
               c = (*p)(a, b); /* c=max(a,b); */
               
   9)返回指针值的函数
      函数的返回值可以是指针类型
      定义形式
         类型 *函数名(参数列表);
   10)指针数组和指向指针的指针
      指针数组
         类型 *数组名[长度];
         元素是指针类型的数组
         举例，char *p[4];
         注意与基类型为数组的指针区分
           char (*p)[4];
      指向指针的指针
         基类型为指针类型的指针
         举例，char **p
    11)void *指针
         定义一个指针，但不指定它指向的数据类型
         不能通过*p引用它指向的数据
         void*指针可以与其他任何类型的指针相互赋值和比较，而不需要显式的强制类型转换
         经常作为函数形参和返回值的类型

       void * 指针变量没有确定类型
         int a=3;
         void *p;
         p =&a; // 赋值给p时自动类型转换
         printf(“%d”,  *(int *) p  ); //输出int数据需要对p的类型强制转换，才能得到正确的结果。

              
11.动态内存分配及其指针变量
   1)malloc函数
      void  *malloc（unsigned int size）
      申请size大小的内存，若成功则返回首字节的指针，不成功则返回NULL。（0）。
      例：
         void *p1;  char *p2;
         p1= malloc (1024);
         p2=(char *)malloc(100*sizeof(char));
   2)calloc 函数
      void *calloc(unsigned n, unsigned size);
      申请n*size大小的内存，若成功则返回首字节的指针，不成功则返回NULL。  

      例：申请内存，50个double数据大小。
         double *p；
         p=(double *)calloc(50, sizeof(double);
   3)free 函数
      void  free（void *p）；
      释放p所指向的动态空间
    free（p）；//p指向已申请的动态内存
   4)realloc 函数
      void *realloc(void *p, unsigned int size);
      将p指向的已获得的动态内存空间重新分配为size大小。

12.结构体
   1)定义
      将不同类型的数据组合成一个整体
      一般形式
         struct [结构体名] {
           成员表列
        };
         “成员表列”形式
           类型 成员名;
           类型 成员名;
   结构体名可以没有，但是这样就无法再次使用该结构体类型了
   成员类型可以是另一结构体类型，但不可直接或间接递归嵌套(自身)；
   成员表列不可为空，至少要有一个成员
   如果结构体类型声明在函数内部，则该函数之外无法引用此结构体类型
   一般把结构体类型声明放到文件最前面,也可以把结构体类型声明放在头文件里
      
   2)成员的引用
      结构体变量名.成员名
      成员运算符 .
         具有最高的优先级，自左向右结合
   3)结构体的整体引用
      结构体类型变量之间可以直接相互赋值
         实质上是两个结构体变量相应的存储空间中的所有数据直接拷贝
         包括复杂类型在内的所有结构体成员都被直接赋值，如字符串、结构体类型等
      函数的实参和形参可以是结构体类型，并且遵循实参到形参的单向值传递规则
      为了提高程序的效率，函数的参数多使用结构体类型指针
   4)指向结构体的指针
      定义、使用与其他基本类型指针类似
      可以使用指向运算符(->)引用指针所指向的结构体的成员
      指向运算符 ->
         结构体指针->成员名
         具有最高的优先级，自左向右结合
         若struct student stu, *p=&stu;
           则stu.num、 (*p).num、  p->num等效
   5)指向结构体数组的指针
      与指向其他基本类型数组的指针用法类似
      注意相关运算符的结合方向和优先级
      ++p->num; /* 同++(p->num); */
      p++->num; /* 同(p++)->num; */
      (++p)->num;
      (p++)->num;
13.链表
   1)形式
      struct node {
         int data;
         struct node *next;
      };
      struct node *head;
      最后一个结点的next指针应为NULL

   2)链表的操作
      链表的建立
         从链尾到链头：新结点插入到链头
         从链头到链尾：新结点插入到链尾
         链表的遍历
      删除结点
         根据一定的条件，删除一个或多个结点
      插入结点
         根据一定的条件，把新结点插入到指定位置

14.共用体
   1)概念：各成员共享同一段内存 — 共用体
      定义：
      union Data  //定义类型
      {  
         int   i;
         char ch;
         float  f;
      } a ; //定义变量
      union Data b, c;  //定义变量
   2)引用：只能引用共用体变量中的成员，而共用体变量不能整体引用。
   3)特点：
         成员共享内存：只能放一个成员的值
         共用体变量初始化只能对一个成员进行（初值表只有一个常量）
         最后一次赋值的成员有效（覆盖了以前所有成员的值）
         共用体变量的地址及其各成员地址都是同一地址
         同类型共用体变量之间可互相赋值
         共用体变量可作函数参数
         可用作结构体成员；共用体成员也可以是数组或结构体
15.用typedef定义类型别名
   一般形式
      typedef <变量定义形式中变量名换成类型名>
   举例
      typedef float REAL; 
      typedef struct {
        int month;
        int day;
        int year;
     } DATE;
16.文件
   1)定义：
      文件：文件是一组相关数据被作为一个整体而存储，通常存储在外存以便在计算机关机时仍能保留。计算机读文件时将它从外存复制到内存，写文件时则从内存传送到外存。
      C语言中的文件
         C语言把文件看作一个字节的序列
         C语言对文件的存取是以字节为单位的
      文本文件(ASCII文件)
         字符序列构成的文件，存储字符（文本）的ASCII码。内容可以以行为单位（以\n划分行）。
      二进制文件
      按数据（如int、float、double或其他复杂类型）在内存中的二进制形式直接存储。

   2)缓冲文件系统
      内存在往外存，读写文件时，都会先经过 输入/输出缓冲文件系统。
      Buffer -缓冲：特殊的内存区域，当输入输出进行时用于“暂存”数据。
      缓冲的目的是为了提高I/O效率.
      buffered I/O, 即通常说的标准I/O 
   3)FILE类型
      保存被使用的文件的有关属性信息
      所有的文件操作都需要FILE类型的指针
      FILE是库文件中定义的结构体的别名
      注意不要写成struct FILE
      举例
         FILE *fp
      typedef struct {
         short          level;  /*缓冲区满空程度*/
         unsigned       flags;  /*文件状态标志*/
         char           fd;     /*文件描述符*/
         unsigned char  hold;   /*无缓冲则不读取字符*/
         short          bsize;  /*缓冲区大小*/
         unsigned char *buffer; /*数据缓冲区*/
         unsigned char *curp;   /*当前位置指针*/
         unsigned       istemp; /*临时文件指示器*/
         short          token;  /*用于有效性检查*/
      } FILE;
   4)文件的打开 (fopen函数)
      函数原型
      FILE *fopen(char *filename,
                 char *mode);
      参数说明
         filename:要打开的文件路径
         mode    :打开模式
      返回值
         若成功，返回指向被打开文件的指针
         若出错，返回空指针NULL(0)
      ----------------------------------------------------------------
         打开模式                     描述
      ----------------------------------------------------------------
            r              只读，打开已有文件，不能写
            w              只写，创建或打开，覆盖已有文件
            a              追加，创建或打开，在已有文件末尾追加
            r+             读写，打开已有文件
            w+             读写，创建或打开，覆盖已有文件
            a+             读写，创建或打开，在已有文件末尾追加
            t              按文本方式打开 (缺省)
            b              按二进制方式打开
      ----------------------------------------------------------------
      二进制方式很简单，读文件时，会原封不动的读出文件的全部內容，写的時候，也是把內存缓冲区的內容原封不动的写到文件中。

　　   而文本方式就不一样了，在读文件时，会将换行符号CRLF(0x0D 0x0A)全部转换成单个的0x0A，并且当遇到结束符CTRLZ(0x1A)时，就认为文件已经结束。
       相应的，写文件时，会将所有的0x0A换成0x0D0x0A。
       要特別注意的是，上面这样的说法仅适用于DOS和Windows系统。在Unix和其他一些系统中，沒有文本方式和二进制方式的区分，使不使用'b'标志都是一样的。
       这是由于不同操作系统对文本文件换行符的定义，和C语言中换行符的定义有所不同而造成的。
   5)文件的关闭 (fclose函数)
      函数原型
         int fclose(FILE *fp);
      参数说明
         fp:要关闭的文件指针
      返回值
         若成功，返回0
         若出错，返回EOF(-1)
      不用的文件应关闭，防止数据破坏丢失
   6)feof函数
      函数原型
         int feof(FILE *fp);
      参数
         fp:文件指针
      返回值
         若文件结束，返回非零值
         若文件尚未结束，返回0
   7) 输出/输入函数
   
      EOF是整数常数
      --------------------------------------------------------------------------------------------------------------------------------------
         函数                    函数原型                            参数                                返回值
      --------------------------------------------------------------------------------------------------------------------------------------
         fwrite      size_t fwrite(void   *buffer,          buffer:要读/写的数据块地址             若成功，返回实际读/写的数据项数量 
                                  size_t  size,            size  :要读/写的每个数据项的字节数     若失败，一般返回0
                                  size_t  count,           count :要读/写的数据项数量
                                  FILE   *fp);             fp    :文件指针
      --------------------------------------------------------------------------------------------------------------------------------------
         fread       size_t fread 同上                      同上                                      同上
      --------------------------------------------------------------------------------------------------------------------------------------
         fputc        int fputc(int c, FILE *fp)；          c :要输出到文件的字符                  若成功，返回输出的字符
                                                            fp:文件指针                            若失败，返回EOF(-1)
      --------------------------------------------------------------------------------------------------------------------------------------
         fgetc        int fgetc(FILE *fp);                  fp:文件指针                            若成功，返回输入的字符
                                                                                                   若失败或文件结束，返回EOF(-1)
      --------------------------------------------------------------------------------------------------------------------------------------
         fputs       int fputs(char *s, FILE *fp);                                                 若成功，返回输出字符个数(或最后的字符)
                                                                                                   若失败，返回EOF
                                                                                                   字符串的结束标志'\0'不会输出到文件
                                                                                                   也不会在字符串末尾自动添加换行符
      --------------------------------------------------------------------------------------------------------------------------------------
         fgets       char *fgets(char *s, int n,                                                   若成功，返回s首地址；若失败，返回NULL
                                FILE *fp);                                                        从fp输入字符串到s中输入n-1个字符，或遇到换行符或EOF为止
                                                                                                   读完后自动在字符串末尾添加'\0'
      --------------------------------------------------------------------------------------------------------------------------------------
         fprintf     int fprintf(FILE *fp,                  类似printf                             
                    char *format[,argument,...]);
      --------------------------------------------------------------------------------------------------------------------------------------
         fscanf      int fscanf(FILE *fp,
                    char *format[,address,...]);
      --------------------------------------------------------------------------------------------------------------------------------------
         putw        int putw(int w, FILE *fp);             w :要输出到文件的整数(字)              若成功，返回输出的整数(字)
                                                            fp:文件指针                            若失败，返回EOF
      --------------------------------------------------------------------------------------------------------------------------------------
         getw        int getw(FILE *fp);                    fp:文件指针                            若成功，返回输入的整数(字)
                                                                                                   若失败，返回EOF
      --------------------------------------------------------------------------------------------------------------------------------------
         
   8)文件的定位函数
      --------------------------------------------------------------------------------------------------------------------------------------
         函数                    函数原型                            参数                                返回值/说明
      --------------------------------------------------------------------------------------------------------------------------------------
         rewind            void rewind(FILE *fp);                 fp:文件指针                         使文件位置指针重新返回文件开头
      --------------------------------------------------------------------------------------------------------------------------------------
         fseek             int fseek(FILE *fp, long offset,       fp:文件指针                         随机改变文件的位置指针
                                   int whence);                  offset:偏移量                       起始位置: SEEK_SET(0):文件开始
                                                                  whence:起始位置                               SEEK_CUR(1):文件当前位置
                                                                                                                SEEK_END(2):文件末尾
      --------------------------------------------------------------------------------------------------------------------------------------
         ftell             long ftell(FILE *fp);                  fp:文件指针                         若成功，返回当前文件指针位置
                                                                                                      若出错，返回-1L
      --------------------------------------------------------------------------------------------------------------------------------------
         feof              int feof(FILE *fp)                     fp:文件指针                         返回非0值，已到文件末尾
                                                                                                      返回0值，还未到文件末尾
      --------------------------------------------------------------------------------------------------------------------------------------



            
   


补充：
  1.宏定义
    1)#ifdef
    i)       
      #ifdef 标识符
        //程序段1
      #else
        //程序段2
      #endif
      它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2
    ii)
      #ifndef 标识符
        //程序段1
      #else
        //程序段2
      #endif
      只是第一行与第一种形式不同：将“ifdef”改为“ifndef”。它的作用是：若标识符未被定义则编译程序段1，否则编译程序段2。这种形式与第一种形式的作用相反 
    iii)
      #if 表达式
        //程序段1
      #else
        //程序段2
      #endif
      它的作用是：当指定的表达式值为真（非零）时就编译程序段1，否则编译程序段2。可以事先给定一定条件，使程序在不同的条件下执行不同的功能。  
    iv)
      #if defined (x)这样的使用，x代表的是一个宏，如果定义了x这个宏，那么，编译器会编译中间的代码。 
  2.typedef
    1)数组
      一维  typedef <元素类型关键字><数组类型名>[<常量表达式>];
      二维  typedef <元素类型关键字><数组类型名>[<常量表达式1>][<常量表达式2>];
      需定义：
        char　line[81];
        char　text[81];
      方法如下：
        typedef char Line[81];
        Line　text,line;
    2)指针
       typedef　char*　pstr;
       int　mystrcmp(pstr　p1,pstr　p3);
    3)结构体
      i)
        typedef与结构结合使用
          typedef　struct　tagMyStruct
          {
            int　iNum;
            long　lLength;
          }MyStruct;
        这语句实际上完成两个操作
          (1) 定义一个新的结构类型
              struct　tagMyStruct
              {
                int　iNum;
                long　lLength;
              };
          (2) typedef为这个新的结构起了一个名字，叫MyStruct。
              typedef struct tagMyStruct MyStruct;
      ii)链表结构体
        (1)
          typedef　struct　tagNode
          {
            char*　pItem;  
            struct　tagNode*　pNext; 
          }*pNode;
        (2)
          typedef　struct　tagNode　pNode;
          struct　tagNode
          {
            char*　pItem;
            pNode*　pNext;
          };
          注意：在这个例子中，你用typedef给一个还未完全声明的类型起新名字。C语言编译器支持这种做法。
        (3)规范做法：
          struct　tagNode
          { 
            char*　pItem; 
            struct　tagNode*　pNext;
          };
 
          typedef　struct　tagNode　pNode;
  3.头文件.h
     "" 和<>包含头文件的区别：""以当前路径为相对路径引用头文件，<>以系统环境变量路径引用头文件
  4.内联函数 inline
     频繁调用的小函数大量消耗栈空间或是叫栈内存
     inline只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如while switch，并且不能内联函数本身不能是直接递归函数(自己内部还调用自己的函数)
  5.#program
    1)#pragma DATA_ALIGN( symbol，constant）
      指令的作用是:排列排列symbol到constant指点的列边界上.
 
      #pragma DATA_ALIGN( rxdata_stream,   128)
      就是让rxdata_stream地址的末尾7位是0（二进制地址），就是128字节对齐。
      对齐的目的，一般是位了CACHE读写外存。
      如果一个CACHE的line是128字节。这样，如果数据128字节对齐，那么取一个128字节的数据，只使用一个CACHE行就
    2)The DATA_SECTION pragma allocates space for the symbol in a section called section name. 
      The syntax for the pragma in C is:
      #pragma DATA_SECTION (symbol, "section name");
      将数据放到 自定义的数据段 默认 .bss
    3)The CODE_SECTION pragma allocates space for the func in a section named section name. The CODE_SECTION pragma is useful 
      if you have code objects that you want to link into an area separate from the .text section.
      The syntax of the pragma in C is:
      #pragma CODE_SECTION (func, section name)
      将代码放到自定义的代码段  默认.text
   6.c/c+++ 中 extern关键字
      http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html
      1 基本解释：extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。
        extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，
                          当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，可以在本模块或其他模块中使用，记住它是一个声明不是定义
      2.：extern “C”
　　    在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？

　　    答案与分析：
　　    C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
　　    下面是一个标准的写法：
        //在.h文件的头上
          #ifndef __INCvxWorksh                      /*防止该头文件被重复引用*/
          #define __INCvxWorksh
          #ifdef __cplusplus                         //__cplusplus是cpp中自定义的一个宏
          #if __cplusplus
          extern "C"{                                //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的
　         #endif
　         #endif /* __cplusplus */ 
　         …
　         …
　         //.h文件结束的地方
　         #ifdef __cplusplus
　         #if __cplusplus
          }
          #endif
          #endif /* __cplusplus */ 
          #endif /* __INCvxWorksh */
        3.小结
          常用方法，在.c中定义变量、函数，在.h中用 extern声明全局变量、函数
                    在工程的某个.c中包含.h文件，就可使用。
                    为了防止多个.c包含该.h文件，在预编译时多次编译，可以在.h中加入      #ifndef __INCvxWorksh                      /*防止该头文件被重复引用*/
                                                                                        #define __INCvxWorksh
    7.void *memcpy(void *dest, const void *src, size_t n);       size_t  字节
